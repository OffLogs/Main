@using OffLogs.Web.Services.Http
@using Microsoft.AspNetCore.Components
@using Microsoft.Extensions.Logging
@using OffLogs.Api.Common.Dto.Entities
@using OffLogs.Api.Common.Dto.RequestsAndResponses.Board.User
@using OffLogs.Business.Common.Constants.Permissions
@using OffLogs.Web.Core.Models.Modal
@inject ILogger<ShareApplicationModal> _logger
@inject IApiService _apiService
@inject ToastService _toastService

<ModalWindow
    IsShow="IsShowModal"
    Buttons="_modalButtons"
    IsLoading="_isLoading"
    OnClose="OnClosed">
    
    <ul class="list-group">
        <OffLogs.Web.Shared.Ui.Form.SelectUserDropDown
            OnUserChanged="OnUserSelectedAsync"
        />
        <hr/>
        @foreach (var user in _sharedUsers)
        {
            <li class="list-group-item d-flex justify-content-between align-items-center">
                @user.UserName
                <MyButton IsSmall="true"></MyButton>
            </li>
        }
        @if (!_sharedUsers.Any())
        {
            <li class="list-group-item d-flex justify-content-between align-items-center">
                This application was not shared yet
            </li>
        }
    </ul>
    
</ModalWindow>

@code {
    [Parameter]
    public bool IsShowModal { get; set; }
    
    [Parameter]
    public long ApplicationId { get; set; }
    
    [Parameter]
    public EventCallback OnClosed { get; set; }
    
    private List<ModalButtonModel> _modalButtons = new ();
    private bool _isLoading = false;
    private long _applicationId;
    private UsersListDto _sharedUsers = new();
    
    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();

        var saveBtnModel = new ModalButtonModel(
            "Add",
            OnClickSave
        )
        {
            IsCloseAfterAction = false
        };
        _modalButtons.Add(saveBtnModel);
        _modalButtons.Add(new (
            "Cancel",
            null,
            BootstrapColorType.Light
        ));
    }

    protected override async Task OnParametersSetAsync()
    {
        await base.OnParametersSetAsync();
        if (_applicationId != ApplicationId)
        {
            _applicationId = ApplicationId;
            await LoadSharedUsersAsync();
        }
    }
    
    private void OnClickSave()
    {
        // InvokeAsync(async () => await SaveSharedUsersAsync());
    }

    private Task OnUserSelectedAsync(UserDto user)
    {
        InvokeAsync(async () => await ShareForUserAsync(user));
        return Task.CompletedTask;
    }

    private async Task ShareForUserAsync(UserDto user)
    {
        try
        {
            await _apiService.PermissionAddAccess(
                PermissionAccessType.ApplicationRead,
                user.Id,
                _applicationId
            );

            _toastService.AddInfoMessage($"Application was shared for {user.UserName}");
        }
        catch (Exception e)
        {
            _toastService.AddErrorMessage(e.Message);
        }
        await InvokeAsync(StateHasChanged);
    }
    
    private async Task RemoveShareForUserAsync(UserDto user)
    {
        try
        {
            await _apiService.PermissionRemoveAccess(
                PermissionAccessType.ApplicationRead,
                user.Id,
                _applicationId
            );

            _toastService.AddInfoMessage($"User access to the application has been removed");
        }
        catch (Exception e)
        {
            _toastService.AddErrorMessage(e.Message);
        }
        await InvokeAsync(StateHasChanged);
    }
    
    private async Task LoadSharedUsersAsync()
    {
        _isLoading = true;
        try
        {
            if (_applicationId > 0)
            {
                _sharedUsers = await _apiService.ApplicationGetSharedUsersAsync(_applicationId);    
            }
            else
            {
                _sharedUsers = new();
            }
        }
        catch (Exception e)
        {
            _toastService.AddServerErrorMessage();
        }
        finally
        {
            _isLoading = false;
        }
        await InvokeAsync(StateHasChanged);
    }
}